---
title: "Accessing relational databases through the dm package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Accessing relational databases through the dm package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Introduction

The main objective of this document is to show how to access transactional data in RDBMS (*Relational Database Management Systems*) and store the star database generated from it in another relational database. Access to the databases is done through the [`dm`](https://cran.r-project.org/package=dm) package, transformations using the `rolap` package. Additionally, a case of multidimensional design from real data is shown.



# Transactional data

We will build on a dataset with transactional data from Czech debit card company specialising on payments at petrol pumps called [CCS](https://relational.fit.cvut.cz/dataset/CCS), publicly available in a RDBMS.

We make a connection by following the instructions they offer, as shown below.

```{r}
library(RMariaDB)

ccs_db <- dbConnect(
  MariaDB(),
  username = "guest",
  password = "relational",
  dbname = "ccs",
  host = "relational.fit.cvut.cz"
)
```

From the connection, we can obtain a `dm` object, indicating in the creation function that it take the keys defined in the database.

```{r, message=FALSE}
library(dm)

ccs_dm <- dm_from_con(ccs_db, learn_keys = TRUE)
```

Using the following function we can display the database tables with all their fields.

```{r}
ccs_dm |>
  dm_draw(view_type = "all")
```

We can access tables as if they were part of a list. If we access the *transactions* table we can see that it has no data, the data is in the *transactions_1k* table hat is not related to the other tables.

```{r}
ccs_dm$transactions
```

On the other hand, the *yearmonth* table contains historical customer data, which we will not use in this example.

Therefore, what we do is generate a new `dm` object by selecting the tables that we are going to use and relating table *transactions_1k* to the rest of the tables. These operations are performed below.

```{r}
ccs_sel_dm <-
  ccs_dm[c('transactions_1k', 'customers', 'gasstations', 'products')] |>
  dm_add_fk(transactions_1k, CustomerID, customers) |>
  dm_add_fk(transactions_1k, GasStationID, gasstations) |>
  dm_add_fk(transactions_1k, ProductID, products)
```

The resulting database schema is shown below.

```{r}
ccs_sel_dm |>
  dm_draw(view_type = "all")
```

To generate a flat table from the database tables we can use the function offered by the `dm` package, as shown below.

```{r, message=FALSE}
transactions_ft <- ccs_sel_dm |>
  dm_flatten_to_tbl(transactions_1k, .recursive = TRUE) |>
  collect()

nrow(transactions_ft)
dput(colnames(transactions_ft))
```

With this we already have in the `transactions_ft` variable the flat table with the transactional data that we are going to use. In the list of fields of the result table, we can see that the fields with the same name that were in several tables are now prefixed with the name of the table they came from.

We can then disconnect from the database.

```{r}
DBI::dbDisconnect(ccs_db)
```


# Star database

From the data of the flat table of the variable `transactions_ft`, we are going to carry out a multidimensional design.

We will start by exploring part of the data to get to know it better.

## Data exploration

The *transactions_1k* table has the *TransactionID* field as its primary key. We check that this field is a surrogate key, autonumber. We check that this field is a surrogate key, autonumber, as shown below.

```{r}
length(unique(transactions_ft$TransactionID))
min(transactions_ft$TransactionID)
max(transactions_ft$TransactionID)
```

As would be expected, in this case, a transaction would correspond to the payment of a customer, by means of a card, for one or several products at a gas station and a specific moment.

We can verify that this is true by obtaining the number of distinct instances for the combinations of attributes of interest.

```{r}
nrow(unique(transactions_ft[, c("Date", "Time", "CustomerID")]))
nrow(unique(transactions_ft[, c("Date", "Time", "CardID")]))
nrow(unique(transactions_ft[, c("Date", "Time", "CardID", "ProductID")]))
```

We deduce that a customer has paid at the same time with more than one card; this has been possible because the time is given in minutes. By adding the product to the combination of attributes that includes card, it is observed that all the rows of the table are obtained.

In view of this, we consider that:

  - A transaction is identified by a card and an instant in time. 
  - A transaction can include several products, each row is a transaction line.

Without loss of generality, let's assume that the card number is not needed to analyse the data (the customer is enough) and we are only interested in the hour in which the transaction occurs, not the specific minute. For the latter, we are going to add an *Hour* field obtained from the *Time* field.

```{r}
transactions_ft <- transactions_ft |> 
  dplyr::mutate(Hour = format(as.POSIXct(Time), format = "%H"))
```

There is nothing remarkable in the rest of the data.

## Star schema

We define the star schema by distributing the attributes into facts and dimensions.

```{r setup}
library(rolap)

s <- star_schema() |>
  define_facts(name = "Transaction Line",
    measures = c("Amount", "Price"),
    nrow_agg = "Rows") |>
  define_dimension(name = "Transaction",
    attributes = c("Date", "Time", "CardID")) |>
  define_dimension(name = "Who",
    attributes = c("CustomerID", "Segment.customers",
                   "Currency")) |>
  define_dimension(name = "Where",
    attributes = c("GasStationID", "ChainID", "Country",
                   "Segment.gasstations")) |>
  define_dimension(name = "When",
    attributes = c("Date", "Hour")) |>
  define_dimension(name = "What",
    attributes = c("Description"))

```

The most remarkable thing about the definition is that the facts correspond to a transaction line, each line corresponding to a product in the transaction. On the other hand, each transaction is identified by the attributes *Date*, *Time* and *CardID*. Since these concepts are not needed for analysis or are already represented in other dimensions, the surrogate key (foreign key in the facts) would be enough to represent the transaction, so it would be a ***degenerate dimension*** (the dimension table is not needed, the foreign key in the facts is enough).

Subsequently, the dimensions could be enriched with other attributes available in the transactional system. In this case, we are going to leave them as they are.

## Star database 

```{r}
db <- star_database(s, transactions_ft) |>
  snake_case() |>
  set_dimension_attribute_names(
    name = "who",
    attributes = c(
      "customer",
      "segment",
      "currency"
    )
  ) |>
  set_dimension_attribute_names(
    name = "where",
    attributes = c(
      "gas_station",
      "chain",
      "country",
      "segment"
    )
  ) |>
  set_dimension_attribute_names(
    name = "what",
    attributes = c(
      "product"
    )
  )
```




```{r}
db_tl <- db |>
  as_tibble_list()

for (i in seq_along(db_tl)){
  cat(sprintf("name: %s, nrow: %d\n", names(db_tl)[i], nrow(db_tl[[i]])))
}

```



```{r}
db_dm <- db |>
  as_dm_class(pk_facts = FALSE)

db_sel_dm <-
  db_dm[c('transaction_line', 'who', 'where', 'when', 'what')]
```

```{r}
db_sel_dm |> 
  dm::dm_draw(rankdir = "LR", view_type = "all")
```


## Store tables in a relational database

In the example below, a local *SQLite* database is used to demonstrate how to store the model in a database. `dm` works with any RDBMS supported by `DBI`.

```{r}
my_db <- DBI::dbConnect(RSQLite::SQLite())
my_db_dm <- dm::copy_dm_to(my_db, db_sel_dm)
my_db_dm
DBI::dbDisconnect(my_db)
```



# Conclusions

