---
title: "Performing Multidimensional Queries Using the `geomultistar` Package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Performing Multidimensional Queries Using the `geomultistar` Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE, message=FALSE}
library(rolap)
```

# Introduction

Once we developed a star database in R using the `rolap` package, in addition to exporting it to exploit it with other tools, we can perform multidimensional queries from R. 

The [`geomultistar`](https://cran.r-project.org/package=geomultistar) package offers the possibility of formulating simple queries on a multidimensional schema and integrating the result with geographic information. We can present the result obtained using the [`sf`](https://cran.r-project.org/package=sf) package and we can also obtain a vector layer of geographic data in *GeoPackage* format.

To use it, we will export an object of class `star_database` to obtain another of class `multistar`, defined in the [`geomultistar`](https://cran.r-project.org/package=geomultistar) package. In this document we are going to show an example of use.


# Classes `star_database` and `geomultistar::multistar`

The variable `mrs_db`, obtained in the vignette titled *Obtaining and transforming flat tables*, `vignette("v05-flat-table-op")`, contains an object of class `star_database` that we will use in the example.

```{r}
class(mrs_db)
```

We can see a representation of the tables it contains using the `draw_tables()` function, as shown below.

```{r}
mrs_db |>
  draw_tables()
```


## Star databases and constellations

Strictly speaking, a *star database* is composed of a fact table and several associated dimension tables. A *constellation* is made up of several star databases that can share dimensions. In the `rolap` package they are treated in a unified way under the `star_database` class: It is used both to define star databases and to define constellations.

It is possible that we are interested in exporting only a star database of the constellation, or a subset of it (also a constellation). For this reason, in this situation, the first step before performing the export operation would be to select the star databases that interest us from the constellation. This operation can be carried out using the `get_star_database()` function, where the names of the star databases are indicated. The names can be obtained using the `get_fact_names()` function.

```{r}
mrs_db |> 
  get_fact_names()
```

Next, we select one of the star databases (also an object of class `star_database`) and display its tables.

```{r}
mrs_st <- mrs_db |> 
  get_star_database("mrs_cause")
class(mrs_st)

mrs_st |>
  draw_tables()
```

## Class `geomultistar::multistar`

Using the `as_multistar()` function we can get a `geomultistar::multistar` object from an object of class `star_database`.  

```{r}
m_db <- mrs_db |>
  as_multistar()
class(m_db)

m_st <- mrs_st |>
  as_multistar()
class(m_st)
```

Like the `star_database` class, the `multistar` class allows us to model both star databases and constellations.


# Query functions

Query functions are defined on a `multistar` object. They allow us to select a subset of the data to obtain a new `multistar` object as a result.

The query is created using `dimensional_query()` and executed using `run_query()`. We can refine it using `select_dimension()`, `select_fact()` and `filter_dimension()` as much as we deem appropriate.

```{r}
library(geomultistar)

ms <- dimensional_query(m_db) |>
  select_dimension(name = "where",
                   attributes = c("region", "state")) |>
  select_dimension(name = "when",
                   attributes = "year") |>
  select_fact(name = "mrs_age",
              measures = "all_deaths") |>
  filter_dimension(name = "when", year >= "2010") |>
  run_query()

class(ms)
```

The result of a query is a `multistar` structure. In this way, we can define queries on the result of others. The result can also be transformed into a flat table.

```{r}
ft <- ms |>
  multistar_as_flat_table()
```

The content of the flat table is shown below.

```{r, results = "asis", echo = FALSE}
pander::pandoc.table(head(ft), split.table = Inf)
```

In the result it can be seen that, as the query has been defined at the year and city level, for a single city, with data available for a single year, there is only one row. Column `nrow_agg` shows the number of original rows that make up the result row.

From the result in the form of a flat table, [`pivottabler`](https://CRAN.R-project.org/package=pivottabler) package can be used to present it in the form of a pivot table.

```{r}
pt <- pivottabler::qpvt(
  ft,
  c("=", "region"),
  c("year"),
  c("Number of Deaths" = "sum(all_deaths)",
    "Rows aggregated" = "sum(nrow_agg)")
)

pt$renderPivot()
```


# Add geographic information

Both the multidimensional data model and multidimensional queries can be enriched with geographic information. This is what we are going to do in this section.

## Define geographic dimensions and attributes

To define the dimensions and geographic attributes of a `multistar` object, we must define a `geomultistar` specialization from it, which allows to store this information.

We create a `geomultistar` object from a `multistar` one defining the names of the dimensions that contain geographic information. In the example only one dimension.

```{r}
gm_db <-
  geomultistar(m_db, geodimension = "where")
```

For each attribute of a geographic dimension that we want to use in queries, we can define a vector geographic data layer with which a relationship can be established using one or more attributes of the dimension.

In the case of `state` the definition is carried out by associating the code to the corresponding one in the layer (`usa_states`).

```{r}
gm_db <- gm_db |>
  define_geoattribute(
    attribute = c("state"),
    from_layer = usa_states,
    by = c("state" = "state")
  ) 
```

Additionally, for an attribute we can generate its layer from the one associated with another related attribute of the dimension. This is what has been done below for `region``.

```{r}
gm_db <- gm_db |>
  define_geoattribute(
    attribute = "region",
    from_attribute = "state"
  ) 
```

In this case, the vector layer is generated from the data available in the layer under consideration. Sometimes this is precisely what is desired. If not, look for a vector layer at that level of detail.

If no attribute name is indicated, this operation is applied to the rest of the attributes of the dimension that do not have an associated vector layer by any of the methods presented, as shown below.

```{r}
gm_db <- gm_db |>
  define_geoattribute(from_attribute = "state")
```

With this we have all the attributes of the dimension with an associated layer, defined at its level of granularity[^1]. On the other hand, we can change the layer of any attribute at any time, independently of the rest.

[^1]: If we are not going to use them in queries it is not necessary that they have the associated layer.

## Run queries adding geographic information

Next we define the same query as before but on the data model enriched with geographic information.

```{r}
vl_sf <- dimensional_query(gm_db) |>
  select_dimension(name = "where",
                   attributes = c("region", "state")) |>
  select_dimension(name = "when",
                   attributes = "year") |>
  select_fact(name = "mrs_age",
              measures = "all_deaths") |>
  filter_dimension(name = "when", year >= "2010") |>
  run_geoquery(wider = TRUE)
```

If instead of executing the standard query, we execute `run_geoquery()` function, we automatically obtain a vector geographic data layer at the finest possible level of detail, depending on the definition of the query. With the parameter `wider = TRUE` we get one row for each geographical instance, this requires adding a data dictionary table.

This data dictionary table and layer structure can be saved in *GeoPackage* format using the `save_as_geopackage()` function. 

```{r}
filepath <- tempdir()
l <- save_as_geopackage(vl_sf, "division", filepath = filepath)

file <- paste0(filepath, "/division.gpkg")
sf::st_layers(file)
```

We can present the vector geographic layer using the functions associated with the `sf` class.

```{r}
plot(vl_sf$sf[,"all_deaths_2016"])
```


# Conclusions

This document presents some of the querying possibilities that we obtain by combining the star databases obtained using the `rolap` package with the functions offered by the `geomultistar` package.

The result is that from R we can define multidimensional queries that can be enriched with geographic information.

