---
title: "Deployment of star databases with incremental refresh"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Deployment of star databases with incremental refresh}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE, message=FALSE}
library(rolap)
```

# Introduction

Once we developed a star database in R, we would like to exploit it directly in R to develop multidimensional queries, but that is part of a future project. Currently we may be interested in deploying it in a RDBMS (*Relational Database Management Systems*) to use it with OLAP (*On-Line Analytical Processing*) query tools.

The **deployment process** consists of **exporting the tables** that make up the star database to the RDBMS and also **keeping them updated**. 

The vignette titled *Incremental refresh of star databases*, `vignette("v40-refresh")`, describes how star databases can be periodically updated based on the new data obtained. These updates are transmitted to the RDBMS automatically using the procedure described in this document.


This document shows by means of an example the possibilities offered by the package in this context. First, the starting data sets are presented. The next section shows how to generate the refresh structures. The following section shows how to perform the incremental refresh. Finally, we present how to make changes to the transformation functions and add these changes for future refresh operations. Finish with the conclusions.


# Starting star database and deployment

This section shows the starting star database and its deployment process.

## Star database

The starting star database is the content in the variable `mrs_db`, obtained in the vignette titled *Obtaining and transforming flat tables*, `vignette("v05-flat-table-op")`. It contains the constellation, formed by two star databases. Next we get their names.

```{r}
library(rolap)

mrs_db |> 
  get_fact_names()
```

The code to generate the constellation from the initial data is available in the vignette. Below is a graphic representation of the tables that make it up.

```{r}
db_dm <- mrs_db |>
  as_dm_class(pk_facts = FALSE)
db_dm |> 
  dm::dm_draw(rankdir = "LR", view_type = "all")
```


## Deployment

To deploy, we need a file to store the star database. In a real case, it would be a file under our control in our folder tree: we only need a file name. For the vignette, let's get a temporary one. 

```{r}
mrs_rdb_file <- tempfile("mrs", fileext = ".rdb")
```

We are going to carry out the deployment on *SQLite*. We will also need a file to store the database. As before, if we use this RDBMS, we would use a file under our control. For the vignette we will use a temporary one.

```{r}
mrs_sqlite_file <- tempfile("mrs", fileext = ".sqlite")
```

The deployment functions must be able to access the database that we use. To give them access to the database, we provide a connection function (it must return an object of class `DBIConnection`) and a disconnection function (it must accept a parameter of class `DBIConnection`).

```{r}
mrs_sqlite_connect <- function() {
  DBI::dbConnect(RSQLite::SQLite(),
                 dbname = mrs_sqlite_file)
}

mrs_sqlite_disconnect <- function(con) {
  DBI::dbDisconnect(con)
}
```

If the disconnection function is like the previous one, we could not indicate it because it is the default one.

With these parameters, we deploy with the `deploy` function, as shown below.

```{r}
mrs_db <- mrs_db |>
  deploy(
    name = "mrs_sqlite",
    connect = mrs_sqlite_connect,
    disconnect = mrs_sqlite_disconnect,
    file = mrs_rdb_file
  )
```

As a result, fact and dimension tables are explored to the database. The star database object is stored (in the file indicated) so that corresponds to the version stored in the relational database. Additionally, from this moment on, the star database and the relational database are linked: refresh operations to the star database will automatically be propagated to the relational database.

## Relational database content

Next, we are going to show the content of the star database and the associated relational database.

For facts and dimensions the number of instances in the star database is shown.

```{r}
l_db <- mrs_db |>
  as_tibble_list()

names <- sort(names(l_db))
for (name in names){
  cat(sprintf("name: %s, %d rows\n", name, nrow(l_db[[name]])))
}
```

We get the same information for the relational database.

```{r}
mrs_con <- mrs_sqlite_connect()

tables <- DBI::dbListTables(mrs_con)
for (t in tables) {
  res <- DBI::dbGetQuery(mrs_con, sprintf('SELECT COUNT(*) FROM `%s`', t))
  cat(sprintf("name: %s, %d rows\n", t, res[[1]]))
}

mrs_sqlite_disconnect(mrs_con)
```

We can see that the tables and their number of instances are the same in both cases.

## Another deployment

We can perform more than one deployment associated with a star database. Next, we get a second temporary file for the new *SQLite* relational database.

```{r}
mrs_sqlite_file_2 <- tempfile("mrs", fileext = ".sqlite")
```

We need a new connection function to use the new file. We define it below.

```{r}
mrs_sqlite_connect_2 <- function() {
  DBI::dbConnect(RSQLite::SQLite(),
                 dbname = mrs_sqlite_file_2)
}
```

In this case we are going to use the default disconnection function and, since a previous deployment has already been carried out, we do not need to indicate any file to store the star database. The call to the display function is as shown below.

```{r}
mrs_db <- mrs_db |>
  deploy(
    name = "mrs_sqlite_2",
    connect = mrs_sqlite_connect_2
  )
```


```{r}
mrs_db |>
  get_deployment_names()
```


# Incremental refresh

## New data

```{r, echo=FALSE}
#  mrs_ft_new: Declared as a variable instead of reading from the file due to problem building macos-latest (release)
```


```{r, eval=FALSE}
file <-
  system.file(
    "extdata",
    "mrs_122_us_cities_1962_2016_new.csv",
    package = "rolap"
  )

mrs_ft_new <-
  read_flat_table_file(name = 'mrs new', file)
```

Using the `read_flat_table_file()` function we read a table stored in a text file and create a `flat_table` object with a name. Below are the first records of the table. We access the table using the `get_table()` function for the object of the `flat_table` class.

```{r, results = "asis"}
ft <- mrs_ft_new |> 
  get_table()

pander::pandoc.table(head(ft), split.table = Inf)
```

## Incremental refresh

```{r}
mrs_db_age_refresh <- mrs_ft_new |>
  update_according_to(mrs_db, star = "mrs_age")
```


```{r}
mrs_db_cause_refresh <- mrs_ft_new |>
  update_according_to(mrs_db, star = "mrs_cause")
```



```{r}
mrs_db <- mrs_db |>
  incremental_refresh(mrs_db_age_refresh) |>
  incremental_refresh(mrs_db_cause_refresh, existing_instances = "group")
```

## Incremental refresh result

Finally, we consult the same data as before again.

```{r}
l_db <- mrs_db |>
  as_tibble_list()

names <- sort(names(l_db))
for (name in names){
  cat(sprintf("name: %s, %d rows\n", name, nrow(l_db[[name]])))
}

cat(paste0(head(sort(l_db[['where']]$city), 15), '\n'))
```




```{r}
mrs_con <- mrs_sqlite_connect()
```


```{r}
tables <- DBI::dbListTables(mrs_con)
for (t in tables) {
  res <- DBI::dbGetQuery(mrs_con, sprintf('SELECT COUNT(*) FROM `%s`', t))
  cat(sprintf("%s: %d\n",t, res[[1]]))
}
```


```{r}
DBI::dbGetQuery(mrs_con, 'SELECT city FROM `where` ORDER BY city LIMIT 15')
```


```{r}
mrs_sqlite_disconnect(mrs_con)
```


## Copy synchronization

```{r}
mrs_db_new <- load_star_database(mrs_rdb_file)
identical(mrs_db, mrs_db_new)
```


```{r}
mrs_db_new |>
  get_deployment_names()
```



```{r, echo = FALSE}
unlink(mrs_rdb_file)
unlink(mrs_sqlite_file)
unlink(mrs_sqlite_file_2)
```


# Conclusions

This document shows the functions supporting incremental refreshing of star databases offered by the `rolap` package.
