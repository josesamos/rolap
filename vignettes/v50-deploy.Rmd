---
title: "Deployment of star databases with incremental refresh"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Deployment of star databases with incremental refresh}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE, message=FALSE}
library(rolap)
```

# Introduction

Once we developed a star database in R, we would like to exploit it directly in R to develop multidimensional queries, but that is part of a future project. Currently we may be interested in deploying it in a RDBMS (*Relational Database Management Systems*) to use it with OLAP (*On-Line Analytical Processing*) query tools.

The **deployment process** consists of **exporting the tables** that make up the star database to the RDBMS and also **keeping them updated**. 

The vignette titled *Incremental refresh of star databases*, `vignette("v40-refresh")`, describes how star databases can be periodically updated based on the new data obtained. These updates are transmitted to the RDBMS automatically using the procedure described in this document.


This document shows by means of an example the possibilities offered by the package in this context. First, the starting data sets are presented. The next section shows how to generate the refresh structures. The following section shows how to perform the incremental refresh. Finally, we present how to make changes to the transformation functions and add these changes for future refresh operations. Finish with the conclusions.


# Starting star database and deployment

This section shows the starting star database and its deployment process.

## Star database

The starting star database is the content in the variable `mrs_db`, obtained in the vignette titled *Obtaining and transforming flat tables*, `vignette("v05-flat-table-op")`. It contains the constellation, formed by two star databases. Next we get their names.

```{r}
library(rolap)

mrs_db |> 
  get_fact_names()
```

The code to generate the constellation from the initial data is available in the vignette. Below is a graphic representation of the tables that make it up.

```{r}
db_dm <- mrs_db |>
  as_dm_class(pk_facts = FALSE)
db_dm |> 
  dm::dm_draw(rankdir = "LR", view_type = "all")
```


## Deployment

To deploy, we need a file to store the star database. In a real case, it would be a file under our control in our folder tree: we only need a file name. For the vignette, let's get a temporary one. 

```{r}
mrs_rdb_file <- tempfile("mrs", fileext = ".rdb")
```

We are going to carry out the deployment on SQLite. We will also need a file to store the database. As before, if we use this RDBMS, we would use a file under our control. For the vignette we will use a temporary one.

```{r}
mrs_sqlite_file <- tempfile("mrs", fileext = ".sqlite")
```

The deployment functions must be able to access the database that we use. To give them access to the database, we provide a connection function (it must return an object of class `DBIConnection`) and another disconnection function (it must accept a parameter of class `DBIConnection`).

```{r}
mrs_sqlite_connect <- function() {
  DBI::dbConnect(RSQLite::SQLite(),
                 dbname = mrs_sqlite_file)
}

mrs_sqlite_disconnect <- function(con) {
  DBI::dbDisconnect(con)
}
```

If the disconnection function is like the previous one, we could not indicate it because it is the default one.

With these parameters, we deploy with the `deploy` function, as shown below.

```{r}
mrs_db <- mrs_db |>
  deploy(
    name = "mrs",
    connect = mrs_sqlite_connect,
    disconnect = mrs_sqlite_disconnect,
    file = mrs_rdb_file
  )
```

As a result, fact tables and dimensions are explored to the database. The star database object is stored (in the file indicated) in a way that corresponds to the version stored in the relational database. Additionally, from this moment on, the star database and the relational database are linked so that  refresh update operations to the star database will automatically be propagated to the relational database.

## Relational database content

```{r}
mrs_con <- mrs_sqlite_connect()
```



```{r}
mrs_sqlite_dm <- dm::dm_from_con(mrs_con, learn_keys = FALSE)
mrs_sqlite_dm |> 
  dm::dm_draw(rankdir = "LR", view_type = "all")
```


To better appreciate the update made, we are going to perform the same query before and after the incremental refresh operation: We obtain the design tables, along with the number of instances of each one. For the *where* dimension table, we get the names of the first cities to check that *Baltimore* and *Boston* were not included.

```{r}
l_db <- mrs_db |>
  as_tibble_list()

names <- sort(names(l_db))
for (name in names){
  cat(sprintf("name: %s, %d rows\n", name, nrow(l_db[[name]])))
}

cat(paste0(head(sort(l_db[['where']]$city), 15), '\n'))
```




```{r}
tables <- DBI::dbListTables(mrs_con)
for (t in tables) {
  res <- DBI::dbGetQuery(mrs_con, sprintf('SELECT COUNT(*) FROM `%s`', t))
  cat(sprintf("%s: %d\n",t, res[[1]]))
}
```


```{r}
DBI::dbGetQuery(mrs_con, 'SELECT city FROM `where` ORDER BY city LIMIT 15')
```



```{r}
mrs_sqlite_disconnect(mrs_con)
```





```{r, echo=FALSE}
#  mrs_ft_new: Declared as a variable instead of reading from the file due to problem building macos-latest (release)
```


```{r, eval=FALSE}
file <-
  system.file(
    "extdata",
    "mrs_122_us_cities_1962_2016_new.csv",
    package = "rolap"
  )

mrs_ft_new <-
  read_flat_table_file(name = 'mrs new', file)
```

Using the `read_flat_table_file()` function we read a table stored in a text file and create a `flat_table` object with a name. Below are the first records of the table. We access the table using the `get_table()` function for the object of the `flat_table` class.

```{r, results = "asis"}
ft <- mrs_ft_new |> 
  get_table()

pander::pandoc.table(head(ft), split.table = Inf)
```



```{r}
mrs_db_age_refresh <- mrs_ft_new |>
  update_according_to(mrs_db, star = "mrs_age")
```


```{r}
mrs_db_cause_refresh <- mrs_ft_new |>
  update_according_to(mrs_db, star = "mrs_cause")
```






```{r}
mrs_db <- mrs_db |>
  incremental_refresh(mrs_db_age_refresh) |>
  incremental_refresh(mrs_db_cause_refresh, existing_instances = "group")
```


Finally, we consult the same data as before again.

```{r}
l_db <- mrs_db |>
  as_tibble_list()

names <- sort(names(l_db))
for (name in names){
  cat(sprintf("name: %s, %d rows\n", name, nrow(l_db[[name]])))
}

cat(paste0(head(sort(l_db[['where']]$city), 15), '\n'))
```




```{r}
mrs_con <- mrs_sqlite_connect()
```


```{r}
tables <- DBI::dbListTables(mrs_con)
for (t in tables) {
  res <- DBI::dbGetQuery(mrs_con, sprintf('SELECT COUNT(*) FROM `%s`', t))
  cat(sprintf("%s: %d\n",t, res[[1]]))
}
```


```{r}
DBI::dbGetQuery(mrs_con, 'SELECT city FROM `where` ORDER BY city LIMIT 15')
```


```{r}
mrs_sqlite_disconnect(mrs_con)
```



```{r}
saveRDS(mrs_db, mrs_rdb_file)
# mrs_db_new <- load_star_database(mrs_rdb_file)
mrs_db_new <- readRDS(mrs_rdb_file)
identical(mrs_db, mrs_db_new)
```




```{r}
unlink(mrs_rdb_file)
unlink(mrs_sqlite_file)
```


# Conclusions

This document shows the functions supporting incremental refreshing of star databases offered by the `rolap` package.
