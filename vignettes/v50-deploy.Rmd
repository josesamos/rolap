---
title: "Deployment of star databases with incremental refresh"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Deployment of star databases with incremental refresh}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE, message=FALSE}
library(rolap)
```

# Introduction

Once we developed a star database in R, we would like to exploit it directly in R to develop multidimensional queries, but that is part of a future project. Currently we may be interested in deploying it in a RDBMS (*Relational Database Management Systems*) to use it with OLAP (*On-Line Analytical Processing*) query tools.

The deployment process consists of exporting the tables that make up the star database to the RDBMS and also **keeping them updated**. 

The vignette titled *Incremental refresh of star databases*, `vignette("v40-refresh")`, describes how star databases can be periodically updated based on the new data obtained. These updates are transmitted to the RDBMS automatically using the procedure described in this document.


This document shows by means of an example the possibilities offered by the package in this context. First, the starting data sets are presented. The next section shows how to generate the refresh structures. The following section shows how to perform the incremental refresh. Finally, we present how to make changes to the transformation functions and add these changes for future refresh operations. Finish with the conclusions.

# Starting data sets

The starting data set is the content in the variable `mrs_db`, obtained in the vignette titled *Obtaining and transforming flat tables*, `vignette("v05-flat-table-op")`. It contains the constellation, formed by two star databases. Next we get their names.

```{r}
library(rolap)

mrs_db |> 
  get_fact_names()
```

The code to generate the constellation from the initial data is available in the vignette. Below is a graphic representation of the tables that make it up.

```{r}
db_dm <- mrs_db |>
  as_dm_class(pk_facts = FALSE)
db_dm |> 
  dm::dm_draw(rankdir = "LR", view_type = "all")
```





```{r}
mrs_rdb_file <- tempfile("mrs", fileext = ".rdb")
```


```{r}
mrs_sqlite_file <- tempfile("mrs", fileext = ".sqlite")
```


```{r}
mrs_sqlite_connect <- function() {
  DBI::dbConnect(RSQLite::SQLite(),
                 dbname = mrs_sqlite_file)
}
```


```{r}
mrs_sqlite_disconnect <- function(con) {
  DBI::dbDisconnect(con)
}
```



```{r}
mrs_db <- mrs_db |>
  deploy(
    name = "mrs",
    connect = mrs_sqlite_connect,
    disconnect = mrs_sqlite_disconnect,
    file = mrs_rdb_file
  )
```



```{r}
mrs_con <- mrs_sqlite_connect()
```



```{r}
mrs_sqlite_dm <- dm::dm_from_con(mrs_con, learn_keys = FALSE)
mrs_sqlite_dm |> 
  dm::dm_draw(rankdir = "LR", view_type = "all")
```



```{r}
tables <- DBI::dbListTables(mrs_con)
for (t in tables) {
  res <- DBI::dbGetQuery(mrs_con, sprintf('SELECT COUNT(*) FROM `%s`', t))
  cat(sprintf("%s: %d\n",t, res[[1]]))
}
```


```{r}
DBI::dbGetQuery(mrs_con, 'SELECT city FROM `where` ORDER BY city LIMIT 15')
```



```{r}
mrs_sqlite_disconnect(mrs_con)
```





```{r, echo=FALSE}
#  mrs_ft_new: Declared as a variable instead of reading from the file due to problem building macos-latest (release)
```


```{r, eval=FALSE}
file <-
  system.file(
    "extdata",
    "mrs_122_us_cities_1962_2016_new.csv",
    package = "rolap"
  )

mrs_ft_new <-
  read_flat_table_file(name = 'mrs new', file)
```

Using the `read_flat_table_file()` function we read a table stored in a text file and create a `flat_table` object with a name. Below are the first records of the table. We access the table using the `get_table()` function for the object of the `flat_table` class.

```{r, results = "asis"}
ft <- mrs_ft_new |> 
  get_table()

pander::pandoc.table(head(ft), split.table = Inf)
```



```{r}
mrs_db_age_refresh <- mrs_ft_new |>
  update_according_to(mrs_db, star = "mrs_age")
```


```{r}
mrs_db_cause_refresh <- mrs_ft_new |>
  update_according_to(mrs_db, star = "mrs_cause")
```






```{r}
mrs_db <- mrs_db |>
  incremental_refresh(mrs_db_age_refresh) |>
  incremental_refresh(mrs_db_cause_refresh, existing_instances = "group")
```






```{r}
mrs_con <- mrs_sqlite_connect()
```


```{r}
tables <- DBI::dbListTables(mrs_con)
for (t in tables) {
  res <- DBI::dbGetQuery(mrs_con, sprintf('SELECT COUNT(*) FROM `%s`', t))
  cat(sprintf("%s: %d\n",t, res[[1]]))
}
```


```{r}
DBI::dbGetQuery(mrs_con, 'SELECT city FROM `where` ORDER BY city LIMIT 15')
```


```{r}
mrs_sqlite_disconnect(mrs_con)
```



```{r}
saveRDS(mrs_db, mrs_rdb_file)
# mrs_db_new <- load_star_database(mrs_rdb_file)
mrs_db_new <- readRDS(mrs_rdb_file)
identical(mrs_db, mrs_db_new)
```




```{r}
unlink(mrs_rdb_file)
unlink(mrs_sqlite_file)
```


# Conclusions

This document shows the functions supporting incremental refreshing of star databases offered by the `rolap` package.
